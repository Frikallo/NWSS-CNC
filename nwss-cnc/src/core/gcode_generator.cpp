#include "core/gcode_generator.h"
#include <fstream>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <cmath>

namespace nwss {
namespace cnc {

GCodeGenerator::GCodeGenerator() = default;
GCodeGenerator::~GCodeGenerator() = default;

void GCodeGenerator::setConfig(const CNConfig& config) {
    m_config = config;
}

void GCodeGenerator::setOptions(const GCodeOptions& options) {
    m_options = options;
}

bool GCodeGenerator::generateGCode(const std::vector<Path>& paths, const std::string& outputFile) const {
    std::ofstream file(outputFile);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open file for writing: " << outputFile << std::endl;
        return false;
    }
    
    // Set precision for output
    file << std::fixed << std::setprecision(4);
    
    // Write header
    if (m_options.includeHeader) {
        writeHeader(file);
    }
    
    // Process each path
    for (size_t pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
        const auto& path = paths[pathIndex];
        if (path.empty()) continue;
        
        writePath(file, path, pathIndex);
    }
    
    // Write footer
    writeFooter(file);
    
    file.close();
    return true;
}

std::string GCodeGenerator::generateGCodeString(const std::vector<Path>& paths) const {
    std::stringstream ss;
    ss << std::fixed << std::setprecision(4);
    
    // Write header
    if (m_options.includeHeader) {
        writeHeader(ss);
    }
    
    // Process each path
    for (size_t pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
        const auto& path = paths[pathIndex];
        if (path.empty()) continue;
        
        writePath(ss, path, pathIndex);
    }
    
    // Write footer
    writeFooter(ss);
    
    return ss.str();
}

void GCodeGenerator::writeHeader(std::ostream& out) const {
    // Get configuration values
    double feedRate = m_config.getFeedRate();
    int spindleSpeed = m_config.getSpindleSpeed();
    double cutDepth = m_config.getCutDepth();
    int passCount = m_config.getPassCount();
    double safeHeight = m_config.getSafeHeight();
    std::string units = m_options.useInches ? "in" : m_config.getUnitsString();
    
    // Write header comments
    // out << "( Generated by NWSS-CNC Software )" << std::endl;
    // out << "( Units: " << units << " )" << std::endl;
    // out << "( Material size: " << m_config.getMaterialWidth() << " x " 
    //     << m_config.getMaterialHeight() << " x "
    //     << m_config.getMaterialThickness() << " " << units << " )" << std::endl;
    // out << "( Cut depth: " << cutDepth << " " << units 
    //     << " x " << passCount << " passes )" << std::endl;
    // out << "( Feed rate: " << feedRate << " " << units << "/min )" << std::endl;
    
    // Include any additional comments
    if (!m_options.comments.empty()) {
        out << "( " << m_options.comments << " )" << std::endl;
    }
    
    out << std::endl;
    
    // Initial setup
    if (m_options.useInches) {
        out << "G20" << std::endl;
    } else {
        out << "G21" << std::endl;
    }
    
    out << "G90" << std::endl;
    // out << "G94         ; Feed rate in units per minute" << std::endl;
    out << "M03 S" << spindleSpeed << std::endl;
    out << "G00 Z" << safeHeight << std::endl << std::endl;
}

void GCodeGenerator::writeFooter(std::ostream& out) const {
    if (m_options.returnToOrigin) {
        out << "G00 Z" << m_config.getSafeHeight() << std::endl;
        out << "G00 X0 Y0" << std::endl;
    }
    
    out << "M05" << std::endl;
    out << "END" << std::endl;
}

void GCodeGenerator::linearizePath(std::ostream& out, const std::vector<Point2D>& points, double feedRate) const {
    if (points.size() < 2) return;
    
    // Start with the first point
    size_t lineStart = 0;
    
    while (lineStart < points.size() - 1) {
        size_t lineEnd = lineStart + 1;
        
        // Try to extend the current line as far as possible
        while (lineEnd + 1 < points.size() && isCollinear(points[lineStart], points[lineEnd], points[lineEnd + 1])) {
            lineEnd++;
        }
        
        // Output the line from start to end
        out << "G01 X" << points[lineEnd].x << " Y" << points[lineEnd].y << " F" << feedRate;
        
        // Add a comment if this is a linearized segment
        if (lineEnd > lineStart + 1) {
            out << "  ; Linearized segment (" << (lineEnd - lineStart + 1) << " points)";
        }
        out << std::endl;
        
        // Move to the next line
        lineStart = lineEnd;
    }
}

bool GCodeGenerator::isCollinear(const Point2D& p1, const Point2D& p2, const Point2D& p3) const {
    // Calculate the area of the triangle formed by the three points
    // If the area is close to zero, the points are collinear
    double area = 0.5 * std::abs((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y));
    
    // Check if the area is less than the tolerance
    return area < m_options.linearizeTolerance;
}

void GCodeGenerator::writePath(std::ostream& out, const Path& path, size_t pathIndex) const {
    const auto& points = path.getPoints();
    if (points.empty()) return;
    
    // Get configuration values
    double feedRate = m_config.getFeedRate();
    double plungeRate = m_config.getPlungeRate();
    double cutDepth = m_config.getCutDepth();
    int passCount = m_config.getPassCount();
    double safeHeight = m_config.getSafeHeight();
    double materialThickness = m_config.getMaterialThickness();
    
    // Add path comment
    out << "( Path " << pathIndex << " )" << std::endl;
    
    // Ensure we're at safe height before rapid move to start point
    out << "G00 Z" << safeHeight << "  ; Retract to safe height before rapid move" << std::endl;
    
    // Move to the start point of the path
    out << "G00 X" << points[0].x << " Y" << points[0].y << "  ; Rapid to start point" << std::endl;
    
    // Make multiple passes if needed
    for (int pass = 0; pass < passCount; pass++) {
        double depth = -cutDepth * (pass + 1);
        
        // Ensure we don't cut deeper than the material thickness
        if (std::abs(depth) > materialThickness) {
            depth = -materialThickness;
            out << "( Note: Depth limited to material thickness )" << std::endl;
        }
        
        // Plunge to depth
        out << "G01 Z" << depth << " F" << plungeRate << "  ; Plunge to depth (pass " << (pass + 1) << ")" << std::endl;
        
        if (m_options.linearizePaths && points.size() > 2) {
            // Linearized path generation
            linearizePath(out, points, feedRate);
        } else {
            // Standard path generation (point by point)
            for (size_t i = 1; i < points.size(); i++) {
                out << "G01 X" << points[i].x << " Y" << points[i].y << " F" << feedRate << std::endl;
            }
        }
        
        // Close the loop if requested and not already closed
        if (m_options.closeLoops && !points.empty() && points.size() > 2) {
            const auto& first = points.front();
            const auto& last = points.back();
            
            // Check if start and end points are different
            double dx = first.x - last.x;
            double dy = first.y - last.y;
            double distance = std::sqrt(dx*dx + dy*dy);
            
            // If the distance is significant, close the loop
            if (distance > 0.001) {
                out << "G01 X" << first.x << " Y" << first.y << " F" << feedRate << "  ; Close loop" << std::endl;
            }
        }
        
        // Retract to safe height between passes and after the last pass
        out << "G00 Z" << safeHeight << "  ; Retract to safe height" << std::endl;
    }
    
    // No need for separate retract option since we always retract now
    // Keep an empty line between paths for readability
    out << std::endl;
}

GCodeGenerator::TimeEstimate GCodeGenerator::calculateTimeEstimate(const std::vector<Path>& paths) const {
    TimeEstimate estimate;
    estimate.rapidTime = 0.0;
    estimate.cuttingTime = 0.0;
    estimate.totalTime = 0.0;
    estimate.totalDistance = 0.0;
    estimate.rapidDistance = 0.0;
    estimate.cuttingDistance = 0.0;
    
    // Get feed rates from config
    double feedRate = m_config.getFeedRate();      // Units per minute
    double plungeRate = m_config.getPlungeRate();  // Units per minute
    double rapidRate = 3000.0;                     // Default rapid rate (units per minute)
    
    // Convert to units per second for calculations
    double feedRatePerSec = feedRate / 60.0;
    double plungeRatePerSec = plungeRate / 60.0;
    double rapidRatePerSec = rapidRate / 60.0;
    
    // Number of passes needed
    int passCount = m_config.getPassCount();
    
    // Process each path
    for (size_t pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
        const auto& path = paths[pathIndex];
        if (path.empty()) continue;
        
        const auto& points = path.getPoints();
        
        // Calculate for each pass
        for (int pass = 0; pass < passCount; pass++) {
            // Initial plunge time - from safe height to cutting depth
            double passDepth = m_config.getCutDepth() * (pass + 1);
            double plungeDistance = passDepth;
            double plungeTime = plungeDistance / plungeRatePerSec;
            estimate.cuttingTime += plungeTime;
            
            // Initial rapid move to the start point (first pass only)
            if (pass == 0 && pathIndex > 0) {
                // Calculate distance from previous path's end point to current path's start point
                const auto& prevPath = paths[pathIndex - 1];
                if (!prevPath.empty()) {
                    const auto& prevEndPoint = prevPath.getPoints().back();
                    const auto& currentStartPoint = points.front();
                    
                    double dx = currentStartPoint.x - prevEndPoint.x;
                    double dy = currentStartPoint.y - prevEndPoint.y;
                    double moveDistance = std::sqrt(dx*dx + dy*dy);
                    
                    estimate.rapidDistance += moveDistance;
                    estimate.rapidTime += moveDistance / rapidRatePerSec;
                }
            }
            
            // Add up all segment lengths
            for (size_t i = 1; i < points.size(); i++) {
                const auto& p1 = points[i-1];
                const auto& p2 = points[i];
                
                double dx = p2.x - p1.x;
                double dy = p2.y - p1.y;
                double distance = std::sqrt(dx*dx + dy*dy);
                
                estimate.cuttingDistance += distance;
                estimate.cuttingTime += distance / feedRatePerSec;
            }
            
            // Retract time - from cutting depth to safe height
            double retractDistance = m_config.getSafeHeight() + passDepth;
            double retractTime = retractDistance / rapidRatePerSec;
            estimate.rapidTime += retractTime;
            estimate.rapidDistance += retractDistance;
        }
    }
    
    // Calculate totals
    estimate.totalDistance = estimate.rapidDistance + estimate.cuttingDistance;
    estimate.totalTime = estimate.rapidTime + estimate.cuttingTime;
    
    return estimate;
}

} // namespace cnc
} // namespace nwss