#include "nwss-cnc/gcode_generator.h"
#include <fstream>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <cmath>

namespace nwss {
namespace cnc {

GCodeGenerator::GCodeGenerator() = default;
GCodeGenerator::~GCodeGenerator() = default;

void GCodeGenerator::setConfig(const CNConfig& config) {
    m_config = config;
}

void GCodeGenerator::setOptions(const GCodeOptions& options) {
    m_options = options;
}

bool GCodeGenerator::generateGCode(const std::vector<Path>& paths, const std::string& outputFile) const {
    std::ofstream file(outputFile);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open file for writing: " << outputFile << std::endl;
        return false;
    }
    
    // Set precision for output
    file << std::fixed << std::setprecision(4);
    
    // Write header
    if (m_options.includeHeader) {
        writeHeader(file);
    }
    
    // Process each path
    for (size_t pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
        const auto& path = paths[pathIndex];
        if (path.empty()) continue;
        
        writePath(file, path, pathIndex);
    }
    
    // Write footer
    writeFooter(file);
    
    file.close();
    return true;
}

std::string GCodeGenerator::generateGCodeString(const std::vector<Path>& paths) const {
    std::stringstream ss;
    ss << std::fixed << std::setprecision(4);
    
    // Write header
    if (m_options.includeHeader) {
        writeHeader(ss);
    }
    
    // Process each path
    for (size_t pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
        const auto& path = paths[pathIndex];
        if (path.empty()) continue;
        
        writePath(ss, path, pathIndex);
    }
    
    // Write footer
    writeFooter(ss);
    
    return ss.str();
}

void GCodeGenerator::writeHeader(std::ostream& out) const {
    // Get configuration values
    double feedRate = m_config.getFeedRate();
    int spindleSpeed = m_config.getSpindleSpeed();
    double cutDepth = m_config.getCutDepth();
    int passCount = m_config.getPassCount();
    double safeHeight = m_config.getSafeHeight();
    std::string units = m_options.useInches ? "in" : m_config.getUnitsString();
    
    // Write header comments
    out << "( Generated by NWSS-CNC SVG Converter )" << std::endl;
    out << "( Units: " << units << " )" << std::endl;
    out << "( Material size: " << m_config.getMaterialWidth() << " x " 
        << m_config.getMaterialHeight() << " x "
        << m_config.getMaterialThickness() << " " << units << " )" << std::endl;
    out << "( Cut depth: " << cutDepth << " " << units 
        << " x " << passCount << " passes )" << std::endl;
    out << "( Feed rate: " << feedRate << " " << units << "/min )" << std::endl;
    
    // Include any additional comments
    if (!m_options.comments.empty()) {
        out << "( " << m_options.comments << " )" << std::endl;
    }
    
    out << std::endl;
    
    // Initial setup
    if (m_options.useInches) {
        out << "G20         ; Set units to inches" << std::endl;
    } else {
        out << "G21         ; Set units to millimeters" << std::endl;
    }
    
    out << "G90         ; Absolute positioning" << std::endl;
    out << "G94         ; Feed rate in units per minute" << std::endl;
    out << "M03 S" << spindleSpeed << "  ; Start spindle" << std::endl;
    out << "G00 Z" << safeHeight << "  ; Move to safe height" << std::endl << std::endl;
}

void GCodeGenerator::writeFooter(std::ostream& out) const {
    if (m_options.returnToOrigin) {
        out << "G00 Z" << m_config.getSafeHeight() << "  ; Move to safe height" << std::endl;
        out << "G00 X0 Y0    ; Return to origin" << std::endl;
    }
    
    out << "M05          ; Stop spindle" << std::endl;
    out << "M02          ; End program" << std::endl;
}

void GCodeGenerator::writePath(std::ostream& out, const Path& path, size_t pathIndex) const {
    const auto& points = path.getPoints();
    if (points.empty()) return;
    
    // Get configuration values
    double feedRate = m_config.getFeedRate();
    double plungeRate = m_config.getPlungeRate();
    double cutDepth = m_config.getCutDepth();
    int passCount = m_config.getPassCount();
    double safeHeight = m_config.getSafeHeight();
    double materialThickness = m_config.getMaterialThickness();
    
    // Add path comment
    out << "( Path " << pathIndex << " )" << std::endl;
    
    // Move to the start point of the path
    out << "G00 X" << points[0].x << " Y" << points[0].y << "  ; Rapid to start point" << std::endl;
    
    // Make multiple passes if needed
    for (int pass = 0; pass < passCount; pass++) {
        double depth = -cutDepth * (pass + 1);
        
        // Ensure we don't cut deeper than the material thickness
        if (std::abs(depth) > materialThickness) {
            depth = -materialThickness;
            out << "( Note: Depth limited to material thickness )" << std::endl;
        }
        
        // Plunge to depth
        out << "G01 Z" << depth << " F" << plungeRate << "  ; Plunge to depth (pass " << (pass + 1) << ")" << std::endl;
        
        // Cut along the path
        for (size_t i = 1; i < points.size(); i++) {
            out << "G01 X" << points[i].x << " Y" << points[i].y << " F" << feedRate << std::endl;
        }
        
        // Close the loop if requested and not already closed
        if (m_options.closeLoops && !points.empty() && points.size() > 2) {
            const auto& first = points.front();
            const auto& last = points.back();
            
            // Check if start and end points are different
            double dx = first.x - last.x;
            double dy = first.y - last.y;
            double distance = std::sqrt(dx*dx + dy*dy);
            
            // If the distance is significant, close the loop
            if (distance > 0.001) {
                out << "G01 X" << first.x << " Y" << first.y << " F" << feedRate << "  ; Close loop" << std::endl;
            }
        }
        
        // Retract to safe height if not the last pass
        if (pass < passCount - 1) {
            out << "G00 Z" << safeHeight << "  ; Retract to safe height" << std::endl;
        }
    }
    
    // Retract after path is complete
    if (m_options.separateRetract) {
        out << "G00 Z" << safeHeight << "  ; Retract to safe height" << std::endl << std::endl;
    }
}

} // namespace cnc
} // namespace nwss