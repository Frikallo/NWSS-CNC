#include "gcode_generator.h"
#include <iostream>
#include <iomanip>
#include <cmath>

GCodeGenerator::GCodeGenerator() : m_decimalPlaces(3), m_useIncrementalMode(false), m_suppressZeroCoordinates(true) {}

GCodeGenerator::~GCodeGenerator() {}

bool GCodeGenerator::generateGCode(const std::vector<ToolpathPoint>& toolpath, 
                                  const MachiningParams& params,
                                  const std::string& outputFilename) {
    std::ofstream file(outputFilename);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot create output file " << outputFilename << std::endl;
        return false;
    }
    
    std::cout << "\n=== Generating G-Code ===" << std::endl;
    std::cout << "Output file: " << outputFilename << std::endl;
    
    // Reset machine state
    m_state = MachineState();
    
    // Write header
    file << generateHeader(params) << std::endl;
    
    // Process toolpath
    int lineNumber = 100; // Start line numbers at N100
    
    for (size_t i = 0; i < toolpath.size(); ++i) {
        const ToolpathPoint& currentPoint = toolpath[i];
        const ToolpathPoint& previousPoint = (i > 0) ? toolpath[i-1] : ToolpathPoint(Point3D(0,0,0));
        
        // Validate move
        if (i > 0 && !validateMove(previousPoint, currentPoint)) {
            std::cerr << "Warning: Invalid move detected at point " << i << std::endl;
        }
        
        // Generate G-code line
        std::string gcodeLine = pointToGCode(currentPoint, previousPoint);
        if (!gcodeLine.empty()) {
            file << "N" << lineNumber << " " << gcodeLine << std::endl;
            lineNumber += 10;
        }
    }
    
    // Write footer
    file << generateFooter(params) << std::endl;
    
    file.close();
    
    std::cout << "Generated " << lineNumber/10 << " G-code lines" << std::endl;
    std::cout << "========================\n" << std::endl;
    
    return true;
}

std::string GCodeGenerator::generateHeader(const MachiningParams& params) const {
    std::ostringstream header;
    
    // Program header with comments
    header << addComment("G-code generated by STL to G-code Converter");
    header << addComment("Material: " + std::to_string(params.material.width) + "x" + 
                        std::to_string(params.material.length) + "x" + 
                        std::to_string(params.material.height));
    header << addComment("Tool: " + std::to_string(params.tool.diameter) + "mm endmill");
    header << addComment("Feedrate: " + std::to_string(params.tool.feedrate) + " mm/min");
    header << addComment("Spindle: " + std::to_string(params.tool.spindleSpeed) + " RPM");
    header << "\n";
    
    // Program initialization
    header << "G90" << addComment("Absolute coordinates");
    header << "G94" << addComment("Feed rate in mm/min");
    header << "G17" << addComment("XY plane selection");
    header << "G40" << addComment("Cancel cutter compensation");
    header << "G49" << addComment("Cancel tool length compensation");
    header << "G80" << addComment("Cancel canned cycles");
    header << "\n";
    
    // Tool setup
    header << generateToolChange(1, params.tool);
    header << generateSpindleOn(params.tool.spindleSpeed);
    header << generateCoolantOn();
    header << "\n";
    
    // Move to safe starting position
    header << "G0 Z" << formatNumber(params.safetyHeight) << addComment("Move to safety height");
    header << "G0 X0 Y0" << addComment("Move to origin");
    
    return header.str();
}

std::string GCodeGenerator::generateFooter(const MachiningParams& params) const {
    std::ostringstream footer;
    
    footer << "\n" << addComment("Program end");
    footer << "G0 Z" << formatNumber(params.safetyHeight) << addComment("Retract to safety");
    footer << generateSpindleOff();
    footer << generateCoolantOff();
    footer << "G0 X0 Y0" << addComment("Return to origin");
    footer << "M30" << addComment("Program end and rewind");
    
    return footer.str();
}

std::string GCodeGenerator::pointToGCode(const ToolpathPoint& point, const ToolpathPoint& previousPoint) const {
    std::ostringstream gcode;
    
    // Determine G-code command based on move type
    std::string command = point.isRapid ? "G0" : "G1";
    
    // Check if we need to output the command
    bool needCommand = (point.isRapid != m_state.isRapidMode);
    
    if (needCommand) {
        gcode << command;
        m_state.isRapidMode = point.isRapid;
    }
    
    // Output coordinates that have changed
    if (needsCoordinateOutput(point.position, m_state.currentPosition)) {
        if (std::abs(point.position.x - m_state.currentPosition.x) > 1e-6) {
            gcode << " " << formatCoordinate(point.position.x, 'X');
        }
        if (std::abs(point.position.y - m_state.currentPosition.y) > 1e-6) {
            gcode << " " << formatCoordinate(point.position.y, 'Y');
        }
        if (std::abs(point.position.z - m_state.currentPosition.z) > 1e-6) {
            gcode << " " << formatCoordinate(point.position.z, 'Z');
        }
        m_state.currentPosition = point.position;
    }
    
    // Output feedrate for cutting moves
    if (!point.isRapid && needsFeedrateOutput(point.feedrate, m_state.currentFeedrate)) {
        gcode << " F" << formatNumber(point.feedrate);
        m_state.currentFeedrate = point.feedrate;
    }
    
    return gcode.str();
}

std::string GCodeGenerator::addComment(const std::string& comment) const {
    return " (" + comment + ")";
}

std::string GCodeGenerator::formatCoordinate(double value, char axis) const {
    return std::string(1, axis) + formatNumber(value);
}

std::string GCodeGenerator::generateToolChange(int toolNumber, const Tool& tool) const {
    std::ostringstream cmd;
    cmd << "T" << toolNumber << " M6" << addComment("Tool change to T" + std::to_string(toolNumber));
    cmd << "\nG43 H" << toolNumber << addComment("Tool length compensation");
    return cmd.str();
}

std::string GCodeGenerator::generateSpindleOn(double speed) const {
    std::ostringstream cmd;
    cmd << "M3 S" << static_cast<int>(speed) << addComment("Spindle on CW");
    return cmd.str();
}

std::string GCodeGenerator::generateSpindleOff() const {
    return "M5" + addComment("Spindle off");
}

std::string GCodeGenerator::generateCoolantOn() const {
    return "M8" + addComment("Coolant on");
}

std::string GCodeGenerator::generateCoolantOff() const {
    return "M9" + addComment("Coolant off");
}

bool GCodeGenerator::needsCoordinateOutput(const Point3D& newPos, const Point3D& currentPos) const {
    const double TOLERANCE = 1e-6;
    
    return (std::abs(newPos.x - currentPos.x) > TOLERANCE ||
            std::abs(newPos.y - currentPos.y) > TOLERANCE ||
            std::abs(newPos.z - currentPos.z) > TOLERANCE);
}

bool GCodeGenerator::needsFeedrateOutput(double newFeedrate, double currentFeedrate) const {
    const double TOLERANCE = 1e-3;
    return std::abs(newFeedrate - currentFeedrate) > TOLERANCE;
}

std::string GCodeGenerator::formatNumber(double value) const {
    std::ostringstream stream;
    stream << std::fixed << std::setprecision(m_decimalPlaces) << value;
    std::string result = stream.str();
    
    // Remove trailing zeros if enabled
    if (m_suppressZeroCoordinates) {
        result.erase(result.find_last_not_of('0') + 1, std::string::npos);
        result.erase(result.find_last_not_of('.') + 1, std::string::npos);
    }
    
    return result;
}

bool GCodeGenerator::validateMove(const ToolpathPoint& from, const ToolpathPoint& to) const {
    // Check for valid coordinates
    if (!isValidCoordinate(to.position.x) || !isValidCoordinate(to.position.y) || !isValidCoordinate(to.position.z)) {
        return false;
    }
    
    // Check for reasonable move distances
    Point3D diff = to.position - from.position;
    double distance = diff.magnitude();
    
    // Warn about very large moves (possible error)
    if (distance > 1000.0) { // 1 meter
        std::cerr << "Warning: Large move distance: " << distance << "mm" << std::endl;
    }
    
    return true;
}

bool GCodeGenerator::isValidCoordinate(double value) const {
    return std::isfinite(value) && std::abs(value) < 1e6; // Reasonable machine limits
}